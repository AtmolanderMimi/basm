// a better brainfuck interpreter
// follows all advice given in the at the end of the
// syntesis chapter about making a bf interpreter
// that being:
//  [x] bulking operators,
//  [x] (and precalculating matching brackets),
//  [] indexing elements of width 2,
//  [] and flipping the program array

[setup] [
ALIS GVplus_op 1;          // `+` -> 1
ALIS GVminus_op 2;         // `-` -> 2
ALIS GVright_tape_op 3;    // `>` -> 3
ALIS GVleft_tape_op 4;     // `<` -> 4
ALIS GVleft_bracket_op 5;  // `[` -> 5
ALIS GVright_bracket_op 6; // `]` -> 6
ALIS GVinput_op 7;         // `,` -> 7
ALIS GVoutput_op 8;        // `.` -> 8

ALIS GVparking 4;
]

// sets a value to a specific value by zeroing it before writing
[@SET Aaddr Vval] [
ZERO Aaddr;
INCR Aaddr Vval;
]

// doubles the cell into the other cell
[@DOUB Asrc Adst] [
// evil aliasing (but actually cool??)
COPY Asrc Adst Adst;
]

// Copies the content of a cell whilst keeping the source (conservatively)
[@COPC Asrc Adst sp] [
	ALIS Atmp sp;
	COPY Asrc Adst Atmp;
	ADDP Asrc Atmp;
]

// if not equal conditional
[@IFNE addr val [scp] sp] [
ALIS tmp sp;
ALIS tmp2 sp+1;

COPY addr tmp tmp2;
ADDP addr tmp2;
WHNE tmp val [
	ZERO tmp;
	
	INLN [scp];

	INCR tmp val;
];

ZERO tmp;
]

// if equal conditional
[@IFEQ addr val [scp] sp] [
ALIS tmp sp;
ALIS sp sp+1;

IFNE addr val [
	INCR tmp 1;
] sp;

IFNE tmp 1 [scp] sp;
ZERO tmp;
]

// Forward assumed pointer
[@FASU Vval] [
BBOX Vval;
ASUM 0;
]

// Backward assumed pointer
[@BASU Vval] [
BBOX 0;
ASUM Vval;
]

// Gets a value from an indexable array dynamically and destructively.
// The indexable array must have at least 3 cells of parking before the provided address.
// At the start we use them like so: `[empty][swap][return][index] ...`.
// Where `swap` is going to be use to swap the first element,
// `index` is the index in the array we desire to get and
// `return` is a value increased every time index is decreased, effectively giving us how far away we are from the start.
// Each time we move forward we want to swap the element in from of us with the empty one at our back.
// Then move the whole structure up by one.
// This creates a kind of "glider" through memory.
// We use the same strategy to go back, but now we don't care about `return` and instead have an element to carry.
// At the end we should arrive at the start of the array like this: `[empty][swap][return][value]`.
// Where `return` should now be 0. 
[@GETD Aarray Aindex Aout] [
ADDP Aarray-1 Aindex; // sets the index

// -- going forward --
// 0 is relative to the back swap cell
BBOX Aarray-3;
ASUM 0;

ALIS Aback_swap 0;
ALIS Areturn 1;
ALIS Aindex 2;
ALIS Aelem 3;

WHNE Aindex 0 [
	DECR Aindex 1;
	INCR Areturn 1;

	ADDP Aback_swap Aelem;
	ADDP Aindex+1 Aindex;
	ADDP Areturn+1 Areturn;

	FASU 1;
];

// -- reached --
ALIS Avalue Aindex;
ALIS Aback_swap Aelem;
ALIS Aelem 0;

ADDP Avalue Aback_swap;

// -- going back --
WHNE Areturn 0 [
	DECR Areturn 1;

	ADDP Areturn-1 Areturn;
	ADDP Avalue-1 Avalue;

	BASU 1;

	ADDP Aback_swap Aelem;
];

// -- got home --
BBOX 0;
ASUM Aarray-3;

ADDP Aout Aarray-1;
]

// Adds a value to a cell in an indexable array dynamically.
// The provided indexable array needs 4 parking cells present before the address.
// Functions like the inverse of `GETD`.
// We start like so: `[swap][return][index][value]`
// We return like so: `[swap][return][0][0] ... `
// (we omit carrying back index and value for return because they will be zero)
[@ADDD Aarray Aindex Avalue] [
ADDP Aarray-2 Aindex; // sets the index
ADDP Aarray-1 Avalue; // sets the value

// -- going forward --
// 0 is relative to the back swap cell
BBOX Aarray-4;
ASUM 0;

ALIS Aback_swap 0;
ALIS Areturn 1;
ALIS Aindex 2;
ALIS Avalue 3;
ALIS Aelem 4;

WHNE Aindex 0 [
	DECR Aindex 1;
	INCR Areturn 1;

	ADDP Aback_swap Aelem;
	ADDP Avalue+1 Avalue;
	ADDP Aindex+1 Aindex;
	ADDP Areturn+1 Areturn;

	FASU 1;
];

// -- reached --
ADDP Aelem Avalue;

ALIS Aback_swap Aelem;
ALIS Aelem 0;


// -- going back --
WHNE Areturn 0 [
	DECR Areturn 1;

	ADDP Areturn-1 Areturn;

	BASU 1;

	ADDP Aback_swap Aelem;
];

// -- got home --
BBOX 0;
ASUM Aarray-4;
]

[@add_if_same_or_shift Vchar Vconvert sp] [
ALIS Vmax_recurrence 254; // 1 less than max, because max is -1 flag
ALIS Aid 0;
ALIS Arecurrence 1;
ALIS Ainput 2;

IFEQ Ainput Vchar [ // if it is the right char
    IFEQ Aid Vconvert [ // if it can extend recurrence
        IFEQ Arecurrence Vmax_recurrence [
            FASU 2;
        ] sp;

        // reset the Aid, or sets it if we moved
        SET Aid Vconvert;
        INCR Arecurrence 1;
    ] sp;

    IFNE Aid Vconvert [
        FASU 2;
        SET Aid Vconvert;
        SET Arecurrence 1;
    ] sp;
] sp;
]

// Gets the program from the user and puts
// it in an array from `sp`.
// Does not store non bf tokens.
// Transforms tokens into id like so:
// * `+` -> 1
// * `-` -> 2
// * `>` -> 3
// * `<` -> 4
// * `[` -> 5
// * `]` -> 6
// * `,` -> 7
// * `.` -> 8
// * end -> 0
// Alongside with the id, elements cells will be next to their recurrence.
// Creating items 2 cells wide like so: [id][recurrence]
// To avoid overflowing the recurrence index, it is capped by a constant.
// Reaching the max, will cause another block to be created.
// Brackets do not store their recurrence (will always be 0).
// User input ends when they enter "!".
// This is an indexable array, this means that the array requires has a set amount of parking determied by GVparking.
// The created array's parking starts at sp and it's contents are at sp+GVparking.
[@input_program sp] [
ALIS Aprog_parking sp;
ALIS Aprog Aprog_parking+GVparking;
ALIS sp Aprog+1;

DECR Aprog-1 1; // used to set a -1 flag at the first from last parking space
BBOX Aprog;
ASUM 0;

BASU 2;

// while we don't get any characters other than '!' to end add to array.
ALIS Aid 0;
ALIS Arecurrence 1;
ALIS Ainput 2;
ALIS Aflag 3;
ALIS Vexit 1;

ALIS sp 4;
WHNE Aflag Vexit [
    IN Ainput;

	add_if_same_or_shift '+' GVplus_op       sp;
	add_if_same_or_shift '-' GVminus_op      sp;
	add_if_same_or_shift '>' GVright_tape_op sp;
	add_if_same_or_shift '<' GVleft_tape_op  sp;

    // these below will always shift, as they can't really recur
	IFEQ Ainput '[' [
        ZERO Ainput;
        FASU 2;

        INCR Aid GVleft_bracket_op;
    ] sp;
	IFEQ Ainput ']' [
        ZERO Ainput;
        FASU 2;

        INCR Aid GVright_bracket_op;
    ] sp;
	IFEQ Ainput ',' [
        ZERO Ainput;
        FASU 2;

        INCR Aid GVinput_op;
    ] sp;
	IFEQ Ainput '.' [
        ZERO Ainput;
        FASU 2;

        INCR Aid GVoutput_op;
    ] sp;

	IFEQ Ainput '!' [
		ZERO Ainput;
		INCR Aflag Vexit;
	] sp;
];
ZERO Aflag;

BBOX 0;
// going back until we reach the -1 flag
RAW "<+[-<+]-";

ASUM Aprog-1;
INCR Aprog-1 1; // remove the -1 flag
]

// calculates the address of matching brackets and puts them in the recurrence
[@calculate_bracket Aprog sp] [
ALIS Aoperator sp;
ALIS Abracket_address sp+1;
ALIS Ainvestigating_address sp+2;
ALIS Aflag sp+3;
ALIS Vexit 1;
ALIS Atmp sp+4;
ALIS sp sp+5;

// iterate through all operators
WHNE Aflag Vexit [
	load_operator Aprog Abracket_address Aoperator sp;
	// we reached the end
	IFEQ Aoperator 0 [
		INCR Aflag Vexit;
	] sp;

	// if '['
	// we only check for '[', not ']', but they will be matched togheter
	IFEQ Aoperator GVleft_bracket_op [
		COPC Abracket_address Ainvestigating_address sp;
		ALIS Abracket_count sp;
		INCR Abracket_count 1;
		ALIS Ainvestigating_operator sp+1;
		ALIS sp sp+2;

		WHNE Abracket_count 0 [
			// get the operator
            INCR Ainvestigating_address 1;
            load_operator Aprog Ainvestigating_address Ainvestigating_operator sp;

			IFEQ Ainvestigating_operator GVleft_bracket_op [ // '['
				INCR Abracket_count 1;
			] sp;

			IFEQ Ainvestigating_operator GVright_bracket_op [ // ']'
				DECR Abracket_count 1;
			] sp;

			// TODO: add check for end of array

			// setting the operator back
            unload_operator Aprog Ainvestigating_address Ainvestigating_operator sp;
		];

		// we are done, Ainvestigating_address is at the matching

		// set recurrence for [
		COPC Ainvestigating_address Atmp sp;
		unload_recurrence Aprog Abracket_address Atmp sp;

		// set recurrence for ]
		COPC Abracket_address Atmp sp;
		unload_recurrence Aprog Ainvestigating_address Atmp sp;
		ZERO Ainvestigating_address;
	] sp;

	unload_operator Aprog Abracket_address Aoperator sp;
	INCR Abracket_address 1;
];
ZERO Aflag;

ZERO Abracket_address;
]

// loads the operator from the Aprog array at Aprog_pointer.
// does not consume Aprog_pointer
[@load_operator Aprog Aprog_pointer Aoperator sp] [
ALIS tmp sp;
ALIS tmp2 sp+1;
ALIS sp sp+2;

// get the operator (at Aprog_pointer*2)
ZERO Aoperator;
COPC Aprog_pointer tmp sp;
DOUB tmp tmp2;
GETD Aprog tmp2 Aoperator;   
]

// loads the operator from the Aprog array at Aprog_pointer.
// does not consume Aprog_pointer
[@load_recurrence Aprog Aprog_pointer Arecurrence sp] [
ALIS tmp sp;
ALIS tmp2 sp+1;
ALIS sp sp+2;

// and recurrence (at (Aprog_pointer*2+1)
ZERO Arecurrence;
COPC Aprog_pointer tmp sp;
DOUB tmp tmp2;
INCR tmp2 1;
GETD Aprog tmp2 Arecurrence;  
]

// unloads the operator (returns it)
[@unload_operator Aprog Aprog_pointer Aoperator sp] [
ALIS tmp sp;
ALIS tmp2 sp+1;
ALIS sp sp+2;

// reset the operator
COPC Aprog_pointer tmp sp;
DOUB tmp tmp2;
ADDD Aprog tmp2 Aoperator;
]

// unloads the recurrence (returns it)
[@unload_recurrence Aprog Aprog_pointer Arecurrence sp] [
ALIS tmp sp;
ALIS tmp2 sp+1;
ALIS sp sp+2;

// reset the recurrence
COPC Aprog_pointer tmp sp;
DOUB tmp tmp2;
INCR tmp2 1;
ADDD Aprog tmp2 Arecurrence;
]

[main] [
ALIS Vgeneral_memory 20;
ALIS Aprog_pointer 0; // points to the element index, not cell index
ALIS Amem_pointer 1;
ALIS Aflag 2;
ALIS Vexit 1;
ALIS Vbracket 2;
ALIS Aoperator 3;
ALIS Arecurrence 4;
ALIS Acell 5;
ALIS Abracket_jump 6; // used to know the pointer position when Aflag is Vbracket
ALIS sp 7;

ALIS Vmax_array_size 250;
ALIS Aprog_parking Vgeneral_memory;
ALIS Aprog Aprog_parking+GVparking;
ALIS Amem Aprog+Vmax_array_size+1;

// -- loading program --
input_program Aprog_parking;
calculate_bracket Aprog sp;

WHNE Aflag Vexit [
	ALIS tmp sp;
	ALIS sp sp+1;

    // loads the operator and recurrence, this does not consume Aprog_pointer
	load_operator   Aprog Aprog_pointer Aoperator   sp;
    load_recurrence Aprog Aprog_pointer Arecurrence sp;

	IFEQ Aoperator GVplus_op [ // '+'
        COPC Arecurrence tmp sp;
		ADDP Acell tmp;
	] sp;
	IFEQ Aoperator GVminus_op [ // '-'
        COPC Arecurrence tmp sp;
		SUBP Acell tmp;
	] sp;
	IFEQ Aoperator GVright_tape_op [ // '>'
		// set the last cell back
		COPC Amem_pointer tmp sp;
		ADDD Amem tmp Acell;

		// get the next cell
        COPC Arecurrence tmp sp;
		ADDP Amem_pointer tmp;
		COPC Amem_pointer tmp sp;
		GETD Amem tmp Acell;
	] sp;
	IFEQ Aoperator GVleft_tape_op [ // '<'
		// set the last cell back
		COPC Amem_pointer tmp sp;
		ADDD Amem tmp Acell;

		// get the next cell
        COPC Arecurrence tmp sp;
		SUBP Amem_pointer tmp; // TODO: may underflow tape pointer
		COPC Amem_pointer tmp sp;
		GETD Amem tmp Acell;
	] sp;

	// -- brackets code upcoming --
	IFEQ Aoperator GVleft_bracket_op [ // '['
		IFEQ Acell 0 [
			COPC Arecurrence tmp sp;
			ADDP Abracket_jump tmp;

			// sets the flag
			INCR Aflag Vbracket;
		] sp;
	] sp;

	IFEQ Aoperator GVright_bracket_op [ // ']'
		IFNE Acell 0 [
			COPC Arecurrence tmp sp;
			ADDP Abracket_jump tmp;

			// sets the flag
			INCR Aflag Vbracket;
		] sp;
	] sp;

	IFEQ Aoperator GVinput_op [ // ','
		IN Acell;
	] sp;
	IFEQ Aoperator GVoutput_op [ // '.'
		OUT Acell;
	] sp;

	IFEQ Aoperator 0 [ // end
		INCR Aflag Vexit;
	] sp;

	// setting the operator back
    unload_operator   Aprog Aprog_pointer Aoperator   sp;
    unload_recurrence Aprog Aprog_pointer Arecurrence sp;

	IFEQ Aflag Vbracket [
		ZERO Aprog_pointer;
		ADDP Aprog_pointer Abracket_jump;
		ZERO Aflag;
	] sp;

	INCR Aprog_pointer 1;
];
]